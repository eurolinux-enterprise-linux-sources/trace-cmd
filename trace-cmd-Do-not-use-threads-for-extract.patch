From 5b0a4e2b6ba87e7351fc0d297c971dfea98fcadd Mon Sep 17 00:00:00 2001
From: Steven Rostedt <srostedt@redhat.com>
Date: Fri, 14 Oct 2011 15:58:19 -0400
Subject: [PATCH 5/7] trace-cmd: Do not use threads for extract

Currently the trace-cmd extract function uses the forked threads to
read the data from the ring buffers. As this is not a live trace and
the program does not end till all the buffers are flushed to disk,
there is no need to use the threads. Just serially read each buffer
into a file and then pull them together normally.

This also fixes a bug that was triggered in the kernel where reading
the trace_pipe_raw file after EOF will yield the last page again,
causing the trace-cmd extract to produce duplicate pages.

Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
Signed-off-by: John Kacur <jkacur@redhat.com>
---
 trace-cmd.c    | 114 ++++++++++++++++++++++++---------------------------------
 trace-cmd.h    |   1 +
 trace-record.c |  37 +++++++++++++------
 3 files changed, 74 insertions(+), 78 deletions(-)

diff --git a/trace-cmd.c b/trace-cmd.c
index 40f542e..42e7117 100644
--- a/trace-cmd.c
+++ b/trace-cmd.c
@@ -155,11 +155,15 @@ static void delete_thread_data(void)
 		return;
 
 	for (i = 0; i < cpu_count; i++) {
-		if (pids[i]) {
+		if (pids) {
+			if (pids[i]) {
+				delete_temp_file(i);
+				if (pids[i] < 0)
+					pids[i] = 0;
+			}
+		} else
+			/* Extract does not allocate pids */
 			delete_temp_file(i);
-			if (pids[i] < 0)
-				pids[i] = 0;
-		}
 	}
 }
 
@@ -179,16 +183,20 @@ static void stop_threads(void)
 	}
 }
 
+static int create_recorder(int cpu, int extract);
+
 static void flush_threads(void)
 {
+	long ret;
 	int i;
 
 	if (!cpu_count)
 		return;
 
 	for (i = 0; i < cpu_count; i++) {
-		if (pids[i] > 0)
-			kill(pids[i], SIGUSR1);
+		ret = create_recorder(i, 1);
+		if (ret < 0)
+			die("error reading ring buffer");
 	}
 }
 
@@ -1009,26 +1017,34 @@ static void set_prio(int prio)
 		warning("failed to set priority");
 }
 
-static int create_recorder(int cpu)
+/*
+ * If extract is set, then this is going to set up the recorder,
+ * connections and exit as the tracing is serialized by a single thread.
+ */
+static int create_recorder(int cpu, int extract)
 {
+	long ret;
 	char *file;
 	int pid;
 
-	pid = fork();
-	if (pid < 0)
-		die("fork");
+	if (!extract) {
+		signal(SIGUSR1, flush);
+		pid = fork();
+		if (pid < 0)
+			die("fork");
 
-	if (pid)
-		return pid;
+		if (pid)
+			return pid;
 
-	signal(SIGINT, finish);
-	signal(SIGUSR1, flush);
+		signal(SIGINT, finish);
+		signal(SIGUSR1, flush);
 
-	if (rt_prio)
-		set_prio(rt_prio);
+		if (rt_prio)
+			set_prio(rt_prio);
 
-	/* do not kill tasks on error */
-	cpu_count = 0;
+		/* do not kill tasks on error */
+		cpu_count = 0;
+	}
 
 	if (client_ports) {
 		connect_port(cpu);
@@ -1041,6 +1057,13 @@ static int create_recorder(int cpu)
 
 	if (!recorder)
 		die ("can't create recorder");
+
+	if (extract) {
+		ret = tracecmd_flush_recording(recorder);
+		tracecmd_free_recorder(recorder);
+		return ret;
+	}
+
 	while (!finished) {
 		if (tracecmd_start_recording(recorder, sleep_time) < 0)
 			break;
@@ -1181,8 +1204,6 @@ static void start_threads(void)
 {
 	int i;
 
-	cpu_count = count_cpus();
-
 	if (host)
 		setup_network();
 
@@ -1192,7 +1213,7 @@ static void start_threads(void)
 	memset(pids, 0, sizeof(*pids) * cpu_count);
 
 	for (i = 0; i < cpu_count; i++) {
-		pids[i] = create_recorder(i);
+		pids[i] = create_recorder(i, 0);
 	}
 }
 
@@ -1229,44 +1250,6 @@ static void record_data(void)
 	tracecmd_output_close(handle);
 }
 
-static int trace_empty(void)
-{
-	char *path;
-	FILE *fp;
-	char *line = NULL;
-	size_t size;
-	ssize_t n;
-	int ret = 1;
-	
-	/*
-	 * Test if the trace file is empty.
-	 *
-	 * Yes, this is a heck of a hack. What is done here
-	 * is to read the trace file and ignore the
-	 * lines starting with '#', and if we get a line
-	 * that is without a '#' the trace is not empty.
-	 * Otherwise it is.
-	 */
-	path = get_tracing_file("trace");
-	fp = fopen(path, "r");
-	if (!fp)
-		die("reading '%s'", path);
-
-	do {
-		n = getline(&line, &size, fp);
-		if (n > 0 && line && line[0] != '#') {
-			ret = 0;
-			break;
-		}
-	} while (line && n > 0);
-
-	put_tracing_file(path);
-
-	fclose(fp);
-
-	return ret;
-}
-
 static void write_func_file(const char *file, struct func_list **list)
 {
 	struct func_list *item;
@@ -1604,17 +1587,17 @@ int main (int argc, char **argv)
 			set_plugin(plugin);
 	}
 
-	if (record || extract) {
+	cpu_count = count_cpus();
+
+	if (record) {
 		if (!latency)
 			start_threads();
 		signal(SIGINT, finish);
 	}
 
 	if (extract) {
-		while (!finished && !trace_empty()) {
-			flush_threads();
-			sleep(1);
-		}
+		flush_threads();
+
 	} else {
 		if (!record) {
 			update_task_filter();
@@ -1632,10 +1615,9 @@ int main (int argc, char **argv)
 		}
 
 		disable_tracing();
+		stop_threads();
 	}
 
-	stop_threads();
-
 	record_data();
 	delete_thread_data();
 
diff --git a/trace-cmd.h b/trace-cmd.h
index 643d394..4df2380 100644
--- a/trace-cmd.h
+++ b/trace-cmd.h
@@ -151,6 +151,7 @@ struct tracecmd_recorder *tracecmd_create_recorder_fd(int fd, int cpu);
 int tracecmd_start_recording(struct tracecmd_recorder *recorder, unsigned long sleep);
 void tracecmd_stop_recording(struct tracecmd_recorder *recorder);
 void tracecmd_stat_cpu(struct trace_seq *s, int cpu);
+long tracecmd_flush_recording(struct tracecmd_recorder *recorder);
 
 
 #endif /* _TRACE_CMD_H */
diff --git a/trace-record.c b/trace-record.c
index e57ef9b..4a01fb9 100644
--- a/trace-record.c
+++ b/trace-record.c
@@ -156,10 +156,32 @@ static long splice_data(struct tracecmd_recorder *recorder)
 	return ret;
 }
 
+long tracecmd_flush_recording(struct tracecmd_recorder *recorder)
+{
+	char *buf[recorder->page_size];
+	long total = 0;
+	long ret;
+
+	do {
+		ret = splice_data(recorder);
+		if (ret < 0)
+			return ret;
+		total += ret;
+	} while (ret);
+
+	/* splice only reads full pages */
+	do {
+		ret = read(recorder->trace_fd, buf, recorder->page_size);
+		if (ret > 0)
+			write(recorder->fd, buf, ret);
+	} while (ret > 0);
+
+	return total;
+}
+
 int tracecmd_start_recording(struct tracecmd_recorder *recorder, unsigned long sleep)
 {
 	struct timespec req;
-	char *buf[recorder->page_size];
 	long ret;
 
 	recorder->stop = 0;
@@ -175,21 +197,12 @@ int tracecmd_start_recording(struct tracecmd_recorder *recorder, unsigned long s
 			return ret;
 	} while (!recorder->stop);
 
-	/* Flush via splice first */
-	do {
-		ret = splice_data(recorder);
-	} while (ret > 0);
+	/* Flush out the rest */
+	ret = tracecmd_flush_recording(recorder);
 
 	if (ret < 0)
 		return ret;
 
-	/* splice only reads full pages */
-	do {
-		ret = read(recorder->trace_fd, buf, recorder->page_size);
-		if (ret > 0)
-			write(recorder->fd, buf, ret);
-	} while (ret > 0);
-
 	return 0;
 }
 
-- 
1.7.11.7

